<!--
 * @Date: 2022-08-28 21:27:41
 * @LastEditors: zhangjiuchao zhangjiuchao@bytedance.com
 * @LastEditTime: 2022-08-28 23:09:44
-->
动态规划
=============
Wiki上动态规划的定义
```
动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题[1]和最优子结构（英语：Optimal substructure）性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
```

在运用动态规划求解问题时，选择的子问题需要满足以下三个条件：
1. 最优子结构性质：每个子问题的解都是最优的。
2. 无后效性：当子问题的解求出来之后便不再改变。
3. 子问题重叠性：在求解其中一个子问题时，需要用到其他子问题的解来求解，动态规划正是用到这个性质来避免了子问题的重复求解
。

动态规划求解中，大问题的最优解是由多个子问题的最优解组成的，所以在选择好子问题的结构后，还需要确定所有子问题最优解到大问题最优解的状态转移方式，也就是递归公式。


# 一维动态规划
形似n个物品排列成一排，以某种特殊的要求选择若干个物品，求最优的解决方案的问题，我们认为是一个一维的动态规划问题。[lc 300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)就是一个典型的一维动态规划问题。

一维动态规划典型的状态转移方程有以下几种：
1. dp[i]：在前i个物品中的最优方案
2. dp[i][1/0]：在前i个物品中，选择或不选择第i个物品的最优方案
3. dp[i][j]: 在前i个物品中，选择第j物品时的最优方案。

以LIS问题为例，关键代码如下:
```c++
dp[1] = 1;
for (int i = 2; i <= n; ++i) {
    dp[i] = 1;
    for (int j = 1; j < i; ++j)
    if (a[i] > a[j]) {
        dp[i] = max(dp[i], dp[j]+1);
    }
}
```

1、 背包问题

背包问题是一种非常常见的问题模型，通常格式是：有N个物品，每个物品有对应的体积$W_i$和$V_i$，要求选出总体积不超过V的几个物品，使得总价值最高。

背包问题可以基于这个模型产生几个变种，比如每种物品的数量可以是一个(0-1背包)、无数个（完全背包）和各有$n_i$个（多重背包）。物品之间可能会相互冲突（分组背包）或相互依赖（具有依赖性的背包问题），背包的体积是多维的（多维背包）等。

各种背包问题的详细讲解可以看一下[《背包9讲》](../resources/%E8%83%8C%E5%8C%859%E8%AE%B2.pdf)。

这里以0-1背包问题举例，用动态规划求解，先确定子问题，不难看出这里的子问题可以描述为将前i个物品放进容积为j的背包中可以得到的最大价值，记为dp[i][j]。

如果只考虑当前状态dp[i][j],如果只考虑是否选择第i个物品，那么问题的其他部分就只与前i-1个物品的状态有关了:
1. 如果我们选择了第i个物品，则dp[i][j] = dp[i-1][j-w[i]] + v[i]，即最大价值为前i-1个物品中当背包体积为j-w[i]时的最大价值加上物品i的价值v[i].
2. 如果我们不选择第i个物品，则dp[i][j] = dp[i-1][j]，即最大价值为前i-1个物品中当背包体积为j时的最大价值。

核心代码：
```c++
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= V; ++j) {
        if (j >= w[i]) {
            dp[i][j] = max(dp[i-1][j-w[i]]+v[i], dp[i-1][j]);
        } else {
            dp[i][j] = dp[i-1][j];
        }
    }
}
```

# 区间动态规划
区间动态规划通常处理的数据也是一维的，它与一维动态规划的区别常常是一段区间的数据作为整体，常见的状态形式为dp[i][j]代表区间[i,j]的这段数据的最优结果。通常边界情况为i>=j;


# 贪心动态规划
在动态规划求解子问题的最优解时，可能会用到贪心思想来进行优化。

# 动态规划进阶

## DAG上dp
当我们需要在DAG上求解最长路径或者固定终点的最长路径时，需要将拓扑排序和动态规划结合起来，在这种用途中，动态规划有一个形象化的名称：记忆化搜索。
```
有n个矩形，每个矩形可以用两个整数来描述，表示它的长与宽。矩形X(a, b) 可以嵌套在矩形 Y(c, d) 中，当且仅当 a < c, b< d 或者 b < c, a < d (矩阵可以旋转90度)。你的任务是选出尽可能多的矩阵排成一行，使得每一个矩形(除最后一个矩阵)都可以嵌套在后一个矩形内。

注：如果有多解，矩形编号的数字尽量小。
```
用一条X指向Y的边代表矩阵X可以嵌套Y，则所有的矩阵可以组成一个有向无环图，则问题可以抽象成找有向无环图的最长路径（无固定起点）。

接下来利用动态规划的思想定义状态dp[i]表示以矩阵i为起点的最长路径。枚举i的所有后向节点edges(i, j), 则dp[i] = max(dp[j] + 1)。

## 四边形不等式

## 状态压缩dp

## 树形dp

## 单调性优化dp

```
滑动区间求最大值
```

